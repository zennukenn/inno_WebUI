import "./chunk-DYWWDCTU.js";
import {
  writable
} from "./chunk-2TOUTEJC.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  not_equal,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_style,
  space,
  subscribe,
  svg_element,
  text,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-HHTL3YMO.js";
import "./chunk-672HPU4M.js";
import "./chunk-I2LLTMMF.js";

// node_modules/svelte-sonner/dist/Icon.svelte
var file = "node_modules/svelte-sonner/dist/Icon.svelte";
function create_else_block(ctx) {
  const block = { c: noop, l: noop, m: noop, d: noop };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(61:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let svg;
  let path0;
  let path1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        viewBox: true,
        fill: true,
        height: true,
        width: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M32.427,7.987c2.183,0.124 4,1.165 5.096,3.281l17.936,36.208c1.739,3.66 -0.954,8.585 -5.373,8.656l-36.119,0c-4.022,-0.064 -7.322,-4.631 -5.352,-8.696l18.271,-36.207c0.342,-0.65 0.498,-0.838 0.793,-1.179c1.186,-1.375 2.483,-2.111 4.748,-2.063Zm-0.295,3.997c-0.687,0.034 -1.316,0.419 -1.659,1.017c-6.312,11.979 -12.397,24.081 -18.301,36.267c-0.546,1.225 0.391,2.797 1.762,2.863c12.06,0.195 24.125,0.195 36.185,0c1.325,-0.064 2.321,-1.584 1.769,-2.85c-5.793,-12.184 -11.765,-24.286 -17.966,-36.267c-0.366,-0.651 -0.903,-1.042 -1.79,-1.03Z");
      add_location(path0, file, 53, 2, 1365);
      attr_dev(path1, "d", "M33.631,40.581l-3.348,0l-0.368,-16.449l4.1,0l-0.384,16.449Zm-3.828,5.03c0,-0.609 0.197,-1.113 0.592,-1.514c0.396,-0.4 0.935,-0.601 1.618,-0.601c0.684,0 1.223,0.201 1.618,0.601c0.395,0.401 0.593,0.905 0.593,1.514c0,0.587 -0.193,1.078 -0.577,1.473c-0.385,0.395 -0.929,0.593 -1.634,0.593c-0.705,0 -1.249,-0.198 -1.634,-0.593c-0.384,-0.395 -0.576,-0.886 -0.576,-1.473Z");
      add_location(path1, file, 56, 2, 1920);
      attr_dev(svg, "viewBox", "0 0 64 64");
      attr_dev(svg, "fill", "currentColor");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "width", "20");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file, 46, 1, 1247);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(46:29) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        height: true,
        width: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "d", "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file, 39, 2, 912);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "fill", "currentColor");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "width", "20");
      add_location(svg, file, 32, 1, 794);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(32:26) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        height: true,
        width: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "d", "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file, 25, 2, 562);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "fill", "currentColor");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "width", "20");
      add_location(svg, file, 18, 1, 444);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(18:27) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        height: true,
        width: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "d", "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file, 11, 2, 192);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "fill", "currentColor");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "width", "20");
      add_location(svg, file, 4, 1, 74);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(4:0) {#if type === 'success'}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[0] === "success"
    ) return create_if_block;
    if (
      /*type*/
      ctx2[0] === "error"
    ) return create_if_block_1;
    if (
      /*type*/
      ctx2[0] === "info"
    ) return create_if_block_2;
    if (
      /*type*/
      ctx2[0] === "warning"
    ) return create_if_block_3;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, []);
  let { type = "success" } = $$props;
  const writable_props = ["type"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2) $$invalidate(0, type = $$props2.type);
  };
  $$self.$capture_state = () => ({ type });
  $$self.$inject_state = ($$props2) => {
    if ("type" in $$props2) $$invalidate(0, type = $$props2.type);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [type];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { type: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment.name
    });
  }
  get type() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;

// node_modules/svelte-sonner/dist/Loader.svelte
var file2 = "node_modules/svelte-sonner/dist/Loader.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  child_ctx[4] = i;
  return child_ctx;
}
function create_each_block(key_1, ctx) {
  let div;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "sonner-loading-bar");
      add_location(div, file2, 7, 3, 191);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(7:2) {#each bars as _, i (i)}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ensure_array_like_dev(
    /*bars*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*i*/
    ctx2[4]
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-visible": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "sonner-spinner");
      add_location(div0, file2, 5, 1, 132);
      attr_dev(div1, "class", "sonner-loading-wrapper");
      attr_dev(
        div1,
        "data-visible",
        /*visible*/
        ctx[0]
      );
      add_location(div1, file2, 4, 0, 71);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*visible*/
      1) {
        attr_dev(
          div1,
          "data-visible",
          /*visible*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Loader", slots, []);
  let { visible } = $$props;
  const bars = Array(12).fill(0);
  $$self.$$.on_mount.push(function() {
    if (visible === void 0 && !("visible" in $$props || $$self.$$.bound[$$self.$$.props["visible"]])) {
      console.warn("<Loader> was created without expected prop 'visible'");
    }
  });
  const writable_props = ["visible"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Loader> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visible" in $$props2) $$invalidate(0, visible = $$props2.visible);
  };
  $$self.$capture_state = () => ({ visible, bars });
  $$self.$inject_state = ($$props2) => {
    if ("visible" in $$props2) $$invalidate(0, visible = $$props2.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [visible, bars];
}
var Loader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { visible: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Loader",
      options,
      id: create_fragment2.name
    });
  }
  get visible() {
    throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Loader_default = Loader;

// node_modules/svelte-sonner/dist/internal/helpers.js
function cn(...classes) {
  return classes.filter(Boolean).join(" ");
}
var isBrowser = typeof document !== "undefined";
function clientWritable(initialValue) {
  const store = writable(initialValue);
  function set(value) {
    if (isBrowser) {
      store.set(value);
    }
  }
  function update(updater) {
    if (isBrowser) {
      store.update(updater);
    }
  }
  return {
    subscribe: store.subscribe,
    set,
    update
  };
}

// node_modules/svelte-sonner/dist/state.js
var toastsCounter = 0;
function createToastState() {
  const toasts = clientWritable([]);
  const heights = clientWritable([]);
  function addToast(data) {
    toasts.update((prev) => [data, ...prev]);
  }
  function create(data) {
    var _a;
    const { message: message2, ...rest } = data;
    const id = typeof (data == null ? void 0 : data.id) === "number" || data.id && ((_a = data.id) == null ? void 0 : _a.length) > 0 ? data.id : toastsCounter++;
    const dismissable = data.dismissable === void 0 ? true : data.dismissable;
    const type = data.type === void 0 ? "default" : data.type;
    const $toasts = get_store_value(toasts);
    const alreadyExists = $toasts.find((toast2) => {
      return toast2.id === id;
    });
    if (alreadyExists) {
      toasts.update((prev) => prev.map((toast2) => {
        if (toast2.id === id) {
          return {
            ...toast2,
            ...data,
            id,
            title: message2,
            dismissable,
            type,
            updated: true
          };
        }
        return {
          ...toast2,
          updated: false
        };
      }));
    } else {
      addToast({ ...rest, id, title: message2, dismissable, type });
    }
    return id;
  }
  function dismiss(id) {
    if (id === void 0) {
      toasts.update((prev) => prev.map((toast2) => ({ ...toast2, dismiss: true })));
      return;
    }
    toasts.update((prev) => prev.map((toast2) => toast2.id === id ? { ...toast2, dismiss: true } : toast2));
    return id;
  }
  function remove(id) {
    if (id === void 0) {
      toasts.set([]);
      return;
    }
    toasts.update((prev) => prev.filter((toast2) => toast2.id !== id));
    return id;
  }
  function message(message2, data) {
    return create({ ...data, type: "default", message: message2 });
  }
  function error(message2, data) {
    return create({ ...data, type: "error", message: message2 });
  }
  function success(message2, data) {
    return create({ ...data, type: "success", message: message2 });
  }
  function info(message2, data) {
    return create({ ...data, type: "info", message: message2 });
  }
  function warning(message2, data) {
    return create({ ...data, type: "warning", message: message2 });
  }
  function loading(message2, data) {
    return create({ ...data, type: "loading", message: message2 });
  }
  function promise(promise2, data) {
    if (!data) {
      return;
    }
    let id = void 0;
    if (data.loading !== void 0) {
      id = create({
        ...data,
        promise: promise2,
        type: "loading",
        message: data.loading
      });
    }
    const p = promise2 instanceof Promise ? promise2 : promise2();
    let shouldDismiss = id !== void 0;
    p.then((response) => {
      if (response && typeof response.ok === "boolean" && !response.ok) {
        shouldDismiss = false;
        const message2 = typeof data.error === "function" ? (
          // @ts-expect-error: Incorrect response type
          data.error(`HTTP error! status: ${response.status}`)
        ) : data.error;
        create({ id, type: "error", message: message2 });
      } else if (data.success !== void 0) {
        shouldDismiss = false;
        const message2 = (
          // @ts-expect-error: TODO: Better function checking
          typeof data.success === "function" ? data.success(response) : data.success
        );
        create({ id, type: "success", message: message2 });
      }
    }).catch((error2) => {
      if (data.error !== void 0) {
        shouldDismiss = false;
        const message2 = (
          // @ts-expect-error: TODO: Better function checking
          typeof data.error === "function" ? data.error(error2) : data.error
        );
        create({ id, type: "error", message: message2 });
      }
    }).finally(() => {
      var _a;
      if (shouldDismiss) {
        dismiss(id);
        id = void 0;
      }
      (_a = data.finally) == null ? void 0 : _a.call(data);
    });
    return id;
  }
  function custom(component, data) {
    const id = (data == null ? void 0 : data.id) || toastsCounter++;
    create({ component, id, ...data });
    return id;
  }
  function removeHeight(id) {
    heights.update((prev) => prev.filter((height) => height.toastId !== id));
  }
  function setHeight(data) {
    const exists = get_store_value(heights).find((el) => el.toastId === data.toastId);
    if (exists === void 0) {
      heights.update((prev) => [data, ...prev]);
      return;
    }
    heights.update((prev) => prev.map((el) => {
      if (el.toastId === data.toastId) {
        return data;
      } else {
        return el;
      }
    }));
  }
  function reset() {
    toasts.set([]);
    heights.set([]);
  }
  return {
    // methods
    create,
    addToast,
    dismiss,
    remove,
    message,
    error,
    success,
    info,
    warning,
    loading,
    promise,
    custom,
    removeHeight,
    setHeight,
    reset,
    // stores
    toasts,
    heights
  };
}
var toastState = createToastState();
function toastFunction(message, data) {
  return toastState.create({
    message,
    ...data
  });
}
var basicToast = toastFunction;
var toast = Object.assign(basicToast, {
  success: toastState.success,
  info: toastState.info,
  warning: toastState.warning,
  error: toastState.error,
  custom: toastState.custom,
  message: toastState.message,
  promise: toastState.promise,
  dismiss: toastState.dismiss,
  loading: toastState.loading
});
var useEffect = (subscribe2) => ({ subscribe: subscribe2 });

// node_modules/svelte-sonner/dist/Toast.svelte
var file3 = "node_modules/svelte-sonner/dist/Toast.svelte";
var get_info_icon_slot_changes = (dirty) => ({});
var get_info_icon_slot_context = (ctx) => ({});
var get_warning_icon_slot_changes = (dirty) => ({});
var get_warning_icon_slot_context = (ctx) => ({});
var get_error_icon_slot_changes = (dirty) => ({});
var get_error_icon_slot_context = (ctx) => ({});
var get_success_icon_slot_changes = (dirty) => ({});
var get_success_icon_slot_context = (ctx) => ({});
var get_loading_icon_slot_changes = (dirty) => ({});
var get_loading_icon_slot_context = (ctx) => ({});
function create_if_block_14(ctx) {
  let button;
  let svg;
  let line0;
  let line1;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "aria-label": true,
        "data-disabled": true,
        "data-close-button": true,
        class: true
      });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b, _c;
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "6");
      attr_dev(line0, "x2", "6");
      attr_dev(line0, "y2", "18");
      add_location(line0, file3, 297, 4, 9097);
      attr_dev(line1, "x1", "6");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "18");
      attr_dev(line1, "y2", "18");
      add_location(line1, file3, 298, 4, 9140);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "12");
      attr_dev(svg, "height", "12");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(svg, "stroke-width", "1.5");
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      add_location(svg, file3, 286, 3, 8869);
      attr_dev(button, "aria-label", "Close toast");
      attr_dev(
        button,
        "data-disabled",
        /*disabled*/
        ctx[22]
      );
      attr_dev(button, "data-close-button", "");
      attr_dev(button, "class", button_class_value = cn(
        /*classes*/
        (_a = ctx[1]) == null ? void 0 : _a.closeButton,
        /*toast*/
        (_c = (_b = ctx[2]) == null ? void 0 : _b.classes) == null ? void 0 : _c.closeButton
      ));
      add_location(button, file3, 274, 2, 8599);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*disabled*/
              ctx[22] ? void 0 : (
                /*click_handler*/
                ctx[49]
              )
            )) /*disabled*/
            (ctx[22] ? void 0 : (
              /*click_handler*/
              ctx[49]
            )).apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      var _a, _b, _c;
      ctx = new_ctx;
      if (dirty[0] & /*disabled*/
      4194304) {
        attr_dev(
          button,
          "data-disabled",
          /*disabled*/
          ctx[22]
        );
      }
      if (dirty[0] & /*classes, toast*/
      6 && button_class_value !== (button_class_value = cn(
        /*classes*/
        (_a = ctx[1]) == null ? void 0 : _a.closeButton,
        /*toast*/
        (_c = (_b = ctx[2]) == null ? void 0 : _b.classes) == null ? void 0 : _c.closeButton
      ))) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(274:1) {#if closeButton && !toast.component}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let if_block4_anchor;
  let current;
  let if_block0 = (
    /*toastType*/
    (ctx[11] !== "default" || /*toast*/
    ctx[2].icon || /*toast*/
    ctx[2].promise) && create_if_block_7(ctx)
  );
  let if_block1 = (
    /*toast*/
    ctx[2].title && create_if_block_5(ctx)
  );
  let if_block2 = (
    /*toast*/
    ctx[2].description && create_if_block_32(ctx)
  );
  let if_block3 = (
    /*toast*/
    ctx[2].cancel && create_if_block_22(ctx)
  );
  let if_block4 = (
    /*toast*/
    ctx[2].action && create_if_block_15(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      div = element("div");
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      if (if_block3) if_block3.c();
      t3 = space();
      if (if_block4) if_block4.c();
      if_block4_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { "data-content": true });
      var div_nodes = children(div);
      if (if_block1) if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2) if_block2.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      if (if_block3) if_block3.l(nodes);
      t3 = claim_space(nodes);
      if (if_block4) if_block4.l(nodes);
      if_block4_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "data-content", "");
      add_location(div, file3, 328, 2, 9961);
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      if (if_block1) if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2) if_block2.m(div, null);
      insert_hydration_dev(target, t2, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert_hydration_dev(target, if_block4_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*toastType*/
        ctx2[11] !== "default" || /*toast*/
        ctx2[2].icon || /*toast*/
        ctx2[2].promise
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*toastType, toast*/
          2052) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*toast*/
        ctx2[2].title
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*toast*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_5(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*toast*/
        ctx2[2].description
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*toast*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_32(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*toast*/
        ctx2[2].cancel
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_22(ctx2);
          if_block3.c();
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*toast*/
        ctx2[2].action
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_15(ctx2);
          if_block4.c();
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(div);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(if_block4_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(310:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*toast*/
    ctx[2].componentProps
  ];
  var switch_value = (
    /*toast*/
    ctx[2].component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*toast*/
    4) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*toast*/
        ctx2[2].componentProps
      )]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on(
      "closeToast",
      /*deleteToast*/
      ctx[30]
    );
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*toast*/
      4 && switch_value !== (switch_value = /*toast*/
      ctx2[2].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          switch_instance.$on(
            "closeToast",
            /*deleteToast*/
            ctx2[30]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*toast*/
        4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*toast*/
          ctx2[2].componentProps
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(304:1) {#if toast.component}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block1;
  let current;
  let if_block0 = (
    /*toast*/
    (ctx[2].promise || /*toastType*/
    ctx[11] === "loading") && !/*toast*/
    ctx[2].icon && create_if_block_13(ctx)
  );
  const if_block_creators = [
    create_if_block_8,
    create_if_block_9,
    create_if_block_10,
    create_if_block_11,
    create_if_block_12
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*toast*/
      ctx2[2].icon
    ) return 0;
    if (
      /*toastType*/
      ctx2[11] === "success"
    ) return 1;
    if (
      /*toastType*/
      ctx2[11] === "error"
    ) return 2;
    if (
      /*toastType*/
      ctx2[11] === "warning"
    ) return 3;
    if (
      /*toastType*/
      ctx2[11] === "info"
    ) return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-icon": true });
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "data-icon", "");
      add_location(div, file3, 311, 3, 9436);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*toast*/
        (ctx2[2].promise || /*toastType*/
        ctx2[11] === "loading") && !/*toast*/
        ctx2[2].icon
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*toast, toastType*/
          2052) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        } else {
          if_block1 = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0) if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(311:2) {#if toastType !== 'default' || toast.icon || toast.promise}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let current;
  const loading_icon_slot_template = (
    /*#slots*/
    ctx[48]["loading-icon"]
  );
  const loading_icon_slot = create_slot(
    loading_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    get_loading_icon_slot_context
  );
  const block = {
    c: function create() {
      if (loading_icon_slot) loading_icon_slot.c();
    },
    l: function claim(nodes) {
      if (loading_icon_slot) loading_icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (loading_icon_slot) {
        loading_icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (loading_icon_slot) {
        if (loading_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            loading_icon_slot,
            loading_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              loading_icon_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              get_loading_icon_slot_changes
            ),
            get_loading_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(loading_icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading_icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (loading_icon_slot) loading_icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(313:4) {#if (toast.promise || toastType === 'loading') && !toast.icon}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let current;
  const info_icon_slot_template = (
    /*#slots*/
    ctx[48]["info-icon"]
  );
  const info_icon_slot = create_slot(
    info_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    get_info_icon_slot_context
  );
  const block = {
    c: function create() {
      if (info_icon_slot) info_icon_slot.c();
    },
    l: function claim(nodes) {
      if (info_icon_slot) info_icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (info_icon_slot) {
        info_icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (info_icon_slot) {
        if (info_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            info_icon_slot,
            info_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              info_icon_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              get_info_icon_slot_changes
            ),
            get_info_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(info_icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(info_icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (info_icon_slot) info_icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(324:35) ",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let current;
  const warning_icon_slot_template = (
    /*#slots*/
    ctx[48]["warning-icon"]
  );
  const warning_icon_slot = create_slot(
    warning_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    get_warning_icon_slot_context
  );
  const block = {
    c: function create() {
      if (warning_icon_slot) warning_icon_slot.c();
    },
    l: function claim(nodes) {
      if (warning_icon_slot) warning_icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (warning_icon_slot) {
        warning_icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (warning_icon_slot) {
        if (warning_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            warning_icon_slot,
            warning_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              warning_icon_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              get_warning_icon_slot_changes
            ),
            get_warning_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warning_icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warning_icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (warning_icon_slot) warning_icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(322:38) ",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let current;
  const error_icon_slot_template = (
    /*#slots*/
    ctx[48]["error-icon"]
  );
  const error_icon_slot = create_slot(
    error_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    get_error_icon_slot_context
  );
  const block = {
    c: function create() {
      if (error_icon_slot) error_icon_slot.c();
    },
    l: function claim(nodes) {
      if (error_icon_slot) error_icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (error_icon_slot) {
        error_icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (error_icon_slot) {
        if (error_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            error_icon_slot,
            error_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              error_icon_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              get_error_icon_slot_changes
            ),
            get_error_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(error_icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (error_icon_slot) error_icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(320:36) ",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let current;
  const success_icon_slot_template = (
    /*#slots*/
    ctx[48]["success-icon"]
  );
  const success_icon_slot = create_slot(
    success_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    get_success_icon_slot_context
  );
  const block = {
    c: function create() {
      if (success_icon_slot) success_icon_slot.c();
    },
    l: function claim(nodes) {
      if (success_icon_slot) success_icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (success_icon_slot) {
        success_icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (success_icon_slot) {
        if (success_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            success_icon_slot,
            success_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              success_icon_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              get_success_icon_slot_changes
            ),
            get_success_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(success_icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(success_icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (success_icon_slot) success_icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(318:38) ",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*toast*/
    ctx[2].icon
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*toast*/
      4 && switch_value !== (switch_value = /*toast*/
      ctx2[2].icon)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(316:4) {#if toast.icon}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block_6, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (typeof /*toast*/
    ctx2[2].title !== "string") return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-title": true, class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b, _c;
      attr_dev(div, "data-title", "");
      attr_dev(div, "class", div_class_value = cn(
        /*classes*/
        (_a = ctx[1]) == null ? void 0 : _a.title,
        /*toast*/
        (_c = (_b = ctx[2]) == null ? void 0 : _b.classes) == null ? void 0 : _c.title
      ));
      add_location(div, file3, 330, 4, 10008);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a, _b, _c;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty[0] & /*classes, toast*/
      6 && div_class_value !== (div_class_value = cn(
        /*classes*/
        (_a = ctx2[1]) == null ? void 0 : _a.title,
        /*toast*/
        (_c = (_b = ctx2[2]) == null ? void 0 : _b.classes) == null ? void 0 : _c.title
      ))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(330:3) {#if toast.title}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let t_value = (
    /*toast*/
    ctx[2].title + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*toast*/
      4 && t_value !== (t_value = /*toast*/
      ctx2[2].title + "")) set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(340:5) {:else}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*toast*/
    ctx[2].componentProps
  ];
  var switch_value = (
    /*toast*/
    ctx[2].title
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*toast*/
    4) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*toast*/
        ctx2[2].componentProps
      )]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*toast*/
      4 && switch_value !== (switch_value = /*toast*/
      ctx2[2].title)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*toast*/
        4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*toast*/
          ctx2[2].componentProps
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(335:5) {#if typeof toast.title !== 'string'}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block_4, create_else_block_1];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (typeof /*toast*/
    ctx2[2].description !== "string") return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-description": true, class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b;
      attr_dev(div, "data-description", "");
      attr_dev(div, "class", div_class_value = cn(
        /*descriptionClass*/
        ctx[9],
        /*toastDescriptionClass*/
        ctx[23],
        /*classes*/
        (_a = ctx[1]) == null ? void 0 : _a.description,
        /*toast*/
        (_b = ctx[2].classes) == null ? void 0 : _b.description
      ));
      add_location(div, file3, 345, 4, 10323);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a, _b;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty[0] & /*descriptionClass, toastDescriptionClass, classes, toast*/
      8389126 && div_class_value !== (div_class_value = cn(
        /*descriptionClass*/
        ctx2[9],
        /*toastDescriptionClass*/
        ctx2[23],
        /*classes*/
        (_a = ctx2[1]) == null ? void 0 : _a.description,
        /*toast*/
        (_b = ctx2[2].classes) == null ? void 0 : _b.description
      ))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(345:3) {#if toast.description}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let t_value = (
    /*toast*/
    ctx[2].description + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*toast*/
      4 && t_value !== (t_value = /*toast*/
      ctx2[2].description + "")) set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(360:5) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*toast*/
    ctx[2].componentProps
  ];
  var switch_value = (
    /*toast*/
    ctx[2].description
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*toast*/
    4) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*toast*/
        ctx2[2].componentProps
      )]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*toast*/
      4 && switch_value !== (switch_value = /*toast*/
      ctx2[2].description)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*toast*/
        4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*toast*/
          ctx2[2].componentProps
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(355:5) {#if typeof toast.description !== 'string'}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let button;
  let t_value = (
    /*toast*/
    ctx[2].cancel.label + ""
  );
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "data-button": true,
        "data-cancel": true,
        style: true,
        class: true
      });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b, _c;
      attr_dev(button, "data-button", "");
      attr_dev(button, "data-cancel", "");
      attr_dev(
        button,
        "style",
        /*cancelButtonStyle*/
        ctx[7]
      );
      attr_dev(button, "class", button_class_value = cn(
        /*classes*/
        (_a = ctx[1]) == null ? void 0 : _a.cancelButton,
        /*toast*/
        (_c = (_b = ctx[2]) == null ? void 0 : _b.classes) == null ? void 0 : _c.cancelButton
      ));
      add_location(button, file3, 366, 3, 10747);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[50],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a, _b, _c;
      if (dirty[0] & /*toast*/
      4 && t_value !== (t_value = /*toast*/
      ctx2[2].cancel.label + "")) set_data_dev(t, t_value);
      if (dirty[0] & /*cancelButtonStyle*/
      128) {
        attr_dev(
          button,
          "style",
          /*cancelButtonStyle*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*classes, toast*/
      6 && button_class_value !== (button_class_value = cn(
        /*classes*/
        (_a = ctx2[1]) == null ? void 0 : _a.cancelButton,
        /*toast*/
        (_c = (_b = ctx2[2]) == null ? void 0 : _b.classes) == null ? void 0 : _c.cancelButton
      ))) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(366:2) {#if toast.cancel}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let button;
  let t_value = (
    /*toast*/
    ctx[2].action.label + ""
  );
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "data-button": true,
        style: true,
        class: true
      });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b, _c;
      attr_dev(button, "data-button", "");
      attr_dev(
        button,
        "style",
        /*actionButtonStyle*/
        ctx[8]
      );
      attr_dev(button, "class", button_class_value = cn(
        /*classes*/
        (_a = ctx[1]) == null ? void 0 : _a.actionButton,
        /*toast*/
        (_c = (_b = ctx[2]) == null ? void 0 : _b.classes) == null ? void 0 : _c.actionButton
      ));
      add_location(button, file3, 382, 3, 11080);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_2*/
          ctx[51],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a, _b, _c;
      if (dirty[0] & /*toast*/
      4 && t_value !== (t_value = /*toast*/
      ctx2[2].action.label + "")) set_data_dev(t, t_value);
      if (dirty[0] & /*actionButtonStyle*/
      256) {
        attr_dev(
          button,
          "style",
          /*actionButtonStyle*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*classes, toast*/
      6 && button_class_value !== (button_class_value = cn(
        /*classes*/
        (_a = ctx2[1]) == null ? void 0 : _a.actionButton,
        /*toast*/
        (_c = (_b = ctx2[2]) == null ? void 0 : _b.classes) == null ? void 0 : _c.actionButton
      ))) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(382:2) {#if toast.action}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let li;
  let t;
  let current_block_type_index;
  let if_block1;
  let li_aria_live_value;
  let li_tabindex_value;
  let li_class_value;
  let li_data_styled_value;
  let li_data_promise_value;
  let li_data_y_position_value;
  let li_data_x_position_value;
  let li_data_expanded_value;
  let li_style_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*closeButton*/
    ctx[6] && !/*toast*/
    ctx[2].component && create_if_block_14(ctx)
  );
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*toast*/
      ctx2[2].component
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      li = element("li");
      if (if_block0) if_block0.c();
      t = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        "aria-live": true,
        "aria-atomic": true,
        role: true,
        tabindex: true,
        class: true,
        "data-sonner-toast": true,
        "data-styled": true,
        "data-mounted": true,
        "data-promise": true,
        "data-removed": true,
        "data-visible": true,
        "data-y-position": true,
        "data-x-position": true,
        "data-index": true,
        "data-front": true,
        "data-swiping": true,
        "data-type": true,
        "data-invert": true,
        "data-swipe-out": true,
        "data-expanded": true,
        style: true
      });
      var li_nodes = children(li);
      if (if_block0) if_block0.l(li_nodes);
      t = claim_space(li_nodes);
      if_block1.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b, _c, _d, _e, _f, _g;
      attr_dev(li, "aria-live", li_aria_live_value = /*toast*/
      ctx[2].important ? "assertive" : "polite");
      attr_dev(li, "aria-atomic", "true");
      attr_dev(li, "role", "status");
      attr_dev(li, "tabindex", li_tabindex_value = 0);
      attr_dev(li, "class", li_class_value = cn(
        /*$$props*/
        ctx[34].class,
        /*toastClass*/
        ctx[24],
        /*classes*/
        (_a = ctx[1]) == null ? void 0 : _a.toast,
        /*toast*/
        (_c = (_b = ctx[2]) == null ? void 0 : _b.classes) == null ? void 0 : _c.toast,
        /*classes*/
        (_d = ctx[1]) == null ? void 0 : _d[
          /*toastType*/
          ctx[11]
        ],
        /*toast*/
        (_f = (_e = ctx[2]) == null ? void 0 : _e.classes) == null ? void 0 : _f[
          /*toastType*/
          ctx[11]
        ]
      ));
      attr_dev(li, "data-sonner-toast", "");
      attr_dev(li, "data-styled", li_data_styled_value = !/*toast*/
      (ctx[2].component || /*toast*/
      ((_g = ctx[2]) == null ? void 0 : _g.unstyled) || /*unstyled*/
      ctx[10]));
      attr_dev(
        li,
        "data-mounted",
        /*mounted*/
        ctx[12]
      );
      attr_dev(li, "data-promise", li_data_promise_value = Boolean(
        /*toast*/
        ctx[2].promise
      ));
      attr_dev(
        li,
        "data-removed",
        /*removed*/
        ctx[13]
      );
      attr_dev(
        li,
        "data-visible",
        /*isVisible*/
        ctx[25]
      );
      attr_dev(li, "data-y-position", li_data_y_position_value = /*coords*/
      ctx[21][0]);
      attr_dev(li, "data-x-position", li_data_x_position_value = /*coords*/
      ctx[21][1]);
      attr_dev(
        li,
        "data-index",
        /*index*/
        ctx[3]
      );
      attr_dev(
        li,
        "data-front",
        /*isFront*/
        ctx[26]
      );
      attr_dev(
        li,
        "data-swiping",
        /*swiping*/
        ctx[14]
      );
      attr_dev(
        li,
        "data-type",
        /*toastType*/
        ctx[11]
      );
      attr_dev(
        li,
        "data-invert",
        /*invert*/
        ctx[0]
      );
      attr_dev(
        li,
        "data-swipe-out",
        /*swipeOut*/
        ctx[15]
      );
      attr_dev(li, "data-expanded", li_data_expanded_value = Boolean(
        /*expanded*/
        ctx[4] || /*expandByDefault*/
        ctx[5] && /*mounted*/
        ctx[12]
      ));
      attr_dev(li, "style", li_style_value = `${/*$$props*/
      ctx[34].style} ${/*toast*/
      ctx[2].style}`);
      set_style(
        li,
        "--index",
        /*index*/
        ctx[3]
      );
      set_style(
        li,
        "--toasts-before",
        /*index*/
        ctx[3]
      );
      set_style(
        li,
        "--z-index",
        /*$toasts*/
        ctx[27].length - /*index*/
        ctx[3]
      );
      set_style(li, "--offset", `${/*removed*/
      ctx[13] ? (
        /*offsetBeforeRemove*/
        ctx[16]
      ) : (
        /*offset*/
        ctx[19]
      )}px`);
      set_style(li, "--initial-height", `${/*initialHeight*/
      ctx[17]}px`);
      add_location(li, file3, 234, 0, 7479);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (if_block0) if_block0.m(li, null);
      append_hydration_dev(li, t);
      if_blocks[current_block_type_index].m(li, null);
      ctx[52](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "pointerdown",
            /*onPointerDown*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "pointerup",
            /*onPointerUp*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "pointermove",
            /*onPointerMove*/
            ctx[33],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (
        /*closeButton*/
        ctx2[6] && !/*toast*/
        ctx2[2].component
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          if_block0.m(li, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(li, null);
      }
      if (!current || dirty[0] & /*toast*/
      4 && li_aria_live_value !== (li_aria_live_value = /*toast*/
      ctx2[2].important ? "assertive" : "polite")) {
        attr_dev(li, "aria-live", li_aria_live_value);
      }
      if (!current || dirty[0] & /*toastClass, classes, toast, toastType*/
      16779270 | dirty[1] & /*$$props*/
      8 && li_class_value !== (li_class_value = cn(
        /*$$props*/
        ctx2[34].class,
        /*toastClass*/
        ctx2[24],
        /*classes*/
        (_a = ctx2[1]) == null ? void 0 : _a.toast,
        /*toast*/
        (_c = (_b = ctx2[2]) == null ? void 0 : _b.classes) == null ? void 0 : _c.toast,
        /*classes*/
        (_d = ctx2[1]) == null ? void 0 : _d[
          /*toastType*/
          ctx2[11]
        ],
        /*toast*/
        (_f = (_e = ctx2[2]) == null ? void 0 : _e.classes) == null ? void 0 : _f[
          /*toastType*/
          ctx2[11]
        ]
      ))) {
        attr_dev(li, "class", li_class_value);
      }
      if (!current || dirty[0] & /*toast, unstyled*/
      1028 && li_data_styled_value !== (li_data_styled_value = !/*toast*/
      (ctx2[2].component || /*toast*/
      ((_g = ctx2[2]) == null ? void 0 : _g.unstyled) || /*unstyled*/
      ctx2[10]))) {
        attr_dev(li, "data-styled", li_data_styled_value);
      }
      if (!current || dirty[0] & /*mounted*/
      4096) {
        attr_dev(
          li,
          "data-mounted",
          /*mounted*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*toast*/
      4 && li_data_promise_value !== (li_data_promise_value = Boolean(
        /*toast*/
        ctx2[2].promise
      ))) {
        attr_dev(li, "data-promise", li_data_promise_value);
      }
      if (!current || dirty[0] & /*removed*/
      8192) {
        attr_dev(
          li,
          "data-removed",
          /*removed*/
          ctx2[13]
        );
      }
      if (!current || dirty[0] & /*isVisible*/
      33554432) {
        attr_dev(
          li,
          "data-visible",
          /*isVisible*/
          ctx2[25]
        );
      }
      if (!current || dirty[0] & /*coords*/
      2097152 && li_data_y_position_value !== (li_data_y_position_value = /*coords*/
      ctx2[21][0])) {
        attr_dev(li, "data-y-position", li_data_y_position_value);
      }
      if (!current || dirty[0] & /*coords*/
      2097152 && li_data_x_position_value !== (li_data_x_position_value = /*coords*/
      ctx2[21][1])) {
        attr_dev(li, "data-x-position", li_data_x_position_value);
      }
      if (!current || dirty[0] & /*index*/
      8) {
        attr_dev(
          li,
          "data-index",
          /*index*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*isFront*/
      67108864) {
        attr_dev(
          li,
          "data-front",
          /*isFront*/
          ctx2[26]
        );
      }
      if (!current || dirty[0] & /*swiping*/
      16384) {
        attr_dev(
          li,
          "data-swiping",
          /*swiping*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*toastType*/
      2048) {
        attr_dev(
          li,
          "data-type",
          /*toastType*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*invert*/
      1) {
        attr_dev(
          li,
          "data-invert",
          /*invert*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*swipeOut*/
      32768) {
        attr_dev(
          li,
          "data-swipe-out",
          /*swipeOut*/
          ctx2[15]
        );
      }
      if (!current || dirty[0] & /*expanded, expandByDefault, mounted*/
      4144 && li_data_expanded_value !== (li_data_expanded_value = Boolean(
        /*expanded*/
        ctx2[4] || /*expandByDefault*/
        ctx2[5] && /*mounted*/
        ctx2[12]
      ))) {
        attr_dev(li, "data-expanded", li_data_expanded_value);
      }
      if (!current || dirty[0] & /*toast*/
      4 | dirty[1] & /*$$props*/
      8 && li_style_value !== (li_style_value = `${/*$$props*/
      ctx2[34].style} ${/*toast*/
      ctx2[2].style}`)) {
        attr_dev(li, "style", li_style_value);
      }
      const style_changed = dirty[0] & /*toast*/
      4 | dirty[1] & /*$$props*/
      8;
      if (dirty[0] & /*index, toast*/
      12 | dirty[1] & /*$$props*/
      8 || style_changed) {
        set_style(
          li,
          "--index",
          /*index*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*index, toast*/
      12 | dirty[1] & /*$$props*/
      8 || style_changed) {
        set_style(
          li,
          "--toasts-before",
          /*index*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*$toasts, index, toast*/
      134217740 | dirty[1] & /*$$props*/
      8 || style_changed) {
        set_style(
          li,
          "--z-index",
          /*$toasts*/
          ctx2[27].length - /*index*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*removed, offsetBeforeRemove, offset, toast*/
      598020 | dirty[1] & /*$$props*/
      8 || style_changed) {
        set_style(li, "--offset", `${/*removed*/
        ctx2[13] ? (
          /*offsetBeforeRemove*/
          ctx2[16]
        ) : (
          /*offset*/
          ctx2[19]
        )}px`);
      }
      if (dirty[0] & /*initialHeight, toast*/
      131076 | dirty[1] & /*$$props*/
      8 || style_changed) {
        set_style(li, "--initial-height", `${/*initialHeight*/
        ctx2[17]}px`);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (if_block0) if_block0.d();
      if_blocks[current_block_type_index].d();
      ctx[52](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var TOAST_LIFETIME = 4e3;
var GAP = 14;
var SWIPE_TRESHOLD = 20;
var TIME_BEFORE_UNMOUNT = 200;
var SCALE_MULTIPLIER = 0.05;
function instance3($$self, $$props, $$invalidate) {
  let isFront;
  let isVisible;
  let toastTitle;
  let toastDescription;
  let toastType;
  let toastClass;
  let toastDescriptionClass;
  let heightIndex;
  let coords;
  let toastsHeightBefore;
  let disabled;
  let isPromiseLoadingOrInfiniteDuration;
  let $effect, $$unsubscribe_effect = noop, $$subscribe_effect = () => ($$unsubscribe_effect(), $$unsubscribe_effect = subscribe(effect, ($$value) => $$invalidate(45, $effect = $$value)), effect);
  let $heights;
  let $toasts;
  $$self.$$.on_destroy.push(() => $$unsubscribe_effect());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toast", slots, ["loading-icon", "success-icon", "error-icon", "warning-icon", "info-icon"]);
  const defaultClasses = {
    toast: "",
    title: "",
    description: "",
    loader: "",
    closeButton: "",
    cancelButton: "",
    actionButton: "",
    action: "",
    warning: "",
    error: "",
    success: "",
    default: "",
    info: "",
    loading: ""
  };
  const { toasts, heights, removeHeight, setHeight, remove } = toastState;
  validate_store(toasts, "toasts");
  component_subscribe($$self, toasts, (value) => $$invalidate(27, $toasts = value));
  validate_store(heights, "heights");
  component_subscribe($$self, heights, (value) => $$invalidate(46, $heights = value));
  let { toast: toast2 } = $$props;
  let { index } = $$props;
  let { expanded } = $$props;
  let { invert } = $$props;
  let { position } = $$props;
  let { visibleToasts } = $$props;
  let { expandByDefault } = $$props;
  let { closeButton } = $$props;
  let { interacting } = $$props;
  let { cancelButtonStyle = "" } = $$props;
  let { actionButtonStyle = "" } = $$props;
  let { duration = 4e3 } = $$props;
  let { descriptionClass = "" } = $$props;
  let { classes = {} } = $$props;
  let { unstyled = false } = $$props;
  let mounted = false;
  let removed = false;
  let swiping = false;
  let swipeOut = false;
  let offsetBeforeRemove = 0;
  let initialHeight = 0;
  let toastRef;
  let offset = 0;
  let closeTimerStartTimeRef = 0;
  let lastCloseTimerStartTimeRef = 0;
  let pointerStartRef = null;
  async function updateHeights() {
    if (!mounted) {
      return;
    }
    await tick();
    let scale;
    if (expanded || expandByDefault) {
      scale = 1;
    } else {
      scale = 1 - index * SCALE_MULTIPLIER;
    }
    toastRef.style.setProperty("height", "auto");
    const offsetHeight = toastRef.offsetHeight;
    const rectHeight = toastRef.getBoundingClientRect().height;
    const scaledRectHeight = Math.round((rectHeight / scale + Number.EPSILON) * 100) / 100;
    toastRef.style.removeProperty("height");
    let finalHeight;
    if (Math.abs(scaledRectHeight - offsetHeight) < 1) {
      finalHeight = scaledRectHeight;
    } else {
      finalHeight = offsetHeight;
    }
    $$invalidate(17, initialHeight = finalHeight);
    setHeight({ toastId: toast2.id, height: finalHeight });
  }
  function deleteToast() {
    $$invalidate(13, removed = true);
    $$invalidate(16, offsetBeforeRemove = offset);
    removeHeight(toast2.id);
    setTimeout(
      () => {
        remove(toast2.id);
      },
      TIME_BEFORE_UNMOUNT
    );
  }
  let timeoutId;
  let remainingTime = toast2.duration || duration || TOAST_LIFETIME;
  function pauseTimer() {
    if (lastCloseTimerStartTimeRef < closeTimerStartTimeRef) {
      const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef;
      remainingTime = remainingTime - elapsedTime;
    }
    lastCloseTimerStartTimeRef = (/* @__PURE__ */ new Date()).getTime();
  }
  function startTimer() {
    closeTimerStartTimeRef = (/* @__PURE__ */ new Date()).getTime();
    $$invalidate(39, timeoutId = setTimeout(
      () => {
        var _a;
        (_a = toast2.onAutoClose) == null ? void 0 : _a.call(toast2, toast2);
        deleteToast();
      },
      remainingTime
    ));
  }
  let effect;
  onMount(() => {
    $$invalidate(12, mounted = true);
    const height = toastRef.getBoundingClientRect().height;
    $$invalidate(17, initialHeight = height);
    setHeight({ toastId: toast2.id, height });
    return () => removeHeight(toast2.id);
  });
  function onPointerDown(event) {
    if (disabled) {
      return;
    }
    $$invalidate(16, offsetBeforeRemove = offset);
    const target = event.target;
    target.setPointerCapture(event.pointerId);
    if (target.tagName === "BUTTON") {
      return;
    }
    $$invalidate(14, swiping = true);
    pointerStartRef = { x: event.clientX, y: event.clientY };
  }
  function onPointerUp() {
    var _a;
    if (swipeOut) {
      return;
    }
    pointerStartRef = null;
    const swipeAmount = Number((toastRef == null ? void 0 : toastRef.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0);
    if (Math.abs(swipeAmount) >= SWIPE_TRESHOLD) {
      $$invalidate(16, offsetBeforeRemove = offset);
      (_a = toast2.onDismiss) == null ? void 0 : _a.call(toast2, toast2);
      deleteToast();
      $$invalidate(15, swipeOut = true);
      return;
    }
    toastRef.style.setProperty("--swipe-amount", "0px");
    $$invalidate(14, swiping = false);
  }
  function onPointerMove(event) {
    if (!pointerStartRef) {
      return;
    }
    const yPosition = event.clientY - pointerStartRef.y;
    const xPosition = event.clientX - pointerStartRef.x;
    const clamp = coords[0] === "top" ? Math.min : Math.max;
    const clampedY = clamp(0, yPosition);
    const swipeStartThreshold = event.pointerType === "touch" ? 10 : 2;
    const isAllowedToSwipe = Math.abs(clampedY) > swipeStartThreshold;
    if (isAllowedToSwipe) {
      toastRef.style.setProperty("--swipe-amount", `${yPosition}px`);
    } else if (Math.abs(xPosition) > swipeStartThreshold) {
      pointerStartRef = null;
    }
  }
  $$self.$$.on_mount.push(function() {
    if (toast2 === void 0 && !("toast" in $$props || $$self.$$.bound[$$self.$$.props["toast"]])) {
      console.warn("<Toast> was created without expected prop 'toast'");
    }
    if (index === void 0 && !("index" in $$props || $$self.$$.bound[$$self.$$.props["index"]])) {
      console.warn("<Toast> was created without expected prop 'index'");
    }
    if (expanded === void 0 && !("expanded" in $$props || $$self.$$.bound[$$self.$$.props["expanded"]])) {
      console.warn("<Toast> was created without expected prop 'expanded'");
    }
    if (invert === void 0 && !("invert" in $$props || $$self.$$.bound[$$self.$$.props["invert"]])) {
      console.warn("<Toast> was created without expected prop 'invert'");
    }
    if (position === void 0 && !("position" in $$props || $$self.$$.bound[$$self.$$.props["position"]])) {
      console.warn("<Toast> was created without expected prop 'position'");
    }
    if (visibleToasts === void 0 && !("visibleToasts" in $$props || $$self.$$.bound[$$self.$$.props["visibleToasts"]])) {
      console.warn("<Toast> was created without expected prop 'visibleToasts'");
    }
    if (expandByDefault === void 0 && !("expandByDefault" in $$props || $$self.$$.bound[$$self.$$.props["expandByDefault"]])) {
      console.warn("<Toast> was created without expected prop 'expandByDefault'");
    }
    if (closeButton === void 0 && !("closeButton" in $$props || $$self.$$.bound[$$self.$$.props["closeButton"]])) {
      console.warn("<Toast> was created without expected prop 'closeButton'");
    }
    if (interacting === void 0 && !("interacting" in $$props || $$self.$$.bound[$$self.$$.props["interacting"]])) {
      console.warn("<Toast> was created without expected prop 'interacting'");
    }
  });
  const click_handler = () => {
    var _a;
    deleteToast();
    (_a = toast2.onDismiss) == null ? void 0 : _a.call(toast2, toast2);
  };
  const click_handler_1 = () => {
    var _a;
    deleteToast();
    if ((_a = toast2.cancel) == null ? void 0 : _a.onClick) {
      toast2.cancel.onClick();
    }
  };
  const click_handler_2 = (event) => {
    var _a;
    (_a = toast2.action) == null ? void 0 : _a.onClick(event);
    if (event.defaultPrevented) return;
    deleteToast();
  };
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      toastRef = $$value;
      $$invalidate(18, toastRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(34, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("toast" in $$new_props) $$invalidate(2, toast2 = $$new_props.toast);
    if ("index" in $$new_props) $$invalidate(3, index = $$new_props.index);
    if ("expanded" in $$new_props) $$invalidate(4, expanded = $$new_props.expanded);
    if ("invert" in $$new_props) $$invalidate(0, invert = $$new_props.invert);
    if ("position" in $$new_props) $$invalidate(35, position = $$new_props.position);
    if ("visibleToasts" in $$new_props) $$invalidate(36, visibleToasts = $$new_props.visibleToasts);
    if ("expandByDefault" in $$new_props) $$invalidate(5, expandByDefault = $$new_props.expandByDefault);
    if ("closeButton" in $$new_props) $$invalidate(6, closeButton = $$new_props.closeButton);
    if ("interacting" in $$new_props) $$invalidate(37, interacting = $$new_props.interacting);
    if ("cancelButtonStyle" in $$new_props) $$invalidate(7, cancelButtonStyle = $$new_props.cancelButtonStyle);
    if ("actionButtonStyle" in $$new_props) $$invalidate(8, actionButtonStyle = $$new_props.actionButtonStyle);
    if ("duration" in $$new_props) $$invalidate(38, duration = $$new_props.duration);
    if ("descriptionClass" in $$new_props) $$invalidate(9, descriptionClass = $$new_props.descriptionClass);
    if ("classes" in $$new_props) $$invalidate(1, classes = $$new_props.classes);
    if ("unstyled" in $$new_props) $$invalidate(10, unstyled = $$new_props.unstyled);
    if ("$$scope" in $$new_props) $$invalidate(47, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    tick,
    toastState,
    useEffect,
    cn,
    TOAST_LIFETIME,
    GAP,
    SWIPE_TRESHOLD,
    TIME_BEFORE_UNMOUNT,
    SCALE_MULTIPLIER,
    defaultClasses,
    toasts,
    heights,
    removeHeight,
    setHeight,
    remove,
    toast: toast2,
    index,
    expanded,
    invert,
    position,
    visibleToasts,
    expandByDefault,
    closeButton,
    interacting,
    cancelButtonStyle,
    actionButtonStyle,
    duration,
    descriptionClass,
    classes,
    unstyled,
    mounted,
    removed,
    swiping,
    swipeOut,
    offsetBeforeRemove,
    initialHeight,
    toastRef,
    offset,
    closeTimerStartTimeRef,
    lastCloseTimerStartTimeRef,
    pointerStartRef,
    updateHeights,
    deleteToast,
    timeoutId,
    remainingTime,
    pauseTimer,
    startTimer,
    effect,
    onPointerDown,
    onPointerUp,
    onPointerMove,
    coords,
    disabled,
    isPromiseLoadingOrInfiniteDuration,
    toastType,
    toastDescription,
    toastTitle,
    toastsHeightBefore,
    heightIndex,
    toastDescriptionClass,
    toastClass,
    isVisible,
    isFront,
    $effect,
    $heights,
    $toasts
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(34, $$props = assign(assign({}, $$props), $$new_props));
    if ("toast" in $$props) $$invalidate(2, toast2 = $$new_props.toast);
    if ("index" in $$props) $$invalidate(3, index = $$new_props.index);
    if ("expanded" in $$props) $$invalidate(4, expanded = $$new_props.expanded);
    if ("invert" in $$props) $$invalidate(0, invert = $$new_props.invert);
    if ("position" in $$props) $$invalidate(35, position = $$new_props.position);
    if ("visibleToasts" in $$props) $$invalidate(36, visibleToasts = $$new_props.visibleToasts);
    if ("expandByDefault" in $$props) $$invalidate(5, expandByDefault = $$new_props.expandByDefault);
    if ("closeButton" in $$props) $$invalidate(6, closeButton = $$new_props.closeButton);
    if ("interacting" in $$props) $$invalidate(37, interacting = $$new_props.interacting);
    if ("cancelButtonStyle" in $$props) $$invalidate(7, cancelButtonStyle = $$new_props.cancelButtonStyle);
    if ("actionButtonStyle" in $$props) $$invalidate(8, actionButtonStyle = $$new_props.actionButtonStyle);
    if ("duration" in $$props) $$invalidate(38, duration = $$new_props.duration);
    if ("descriptionClass" in $$props) $$invalidate(9, descriptionClass = $$new_props.descriptionClass);
    if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
    if ("unstyled" in $$props) $$invalidate(10, unstyled = $$new_props.unstyled);
    if ("mounted" in $$props) $$invalidate(12, mounted = $$new_props.mounted);
    if ("removed" in $$props) $$invalidate(13, removed = $$new_props.removed);
    if ("swiping" in $$props) $$invalidate(14, swiping = $$new_props.swiping);
    if ("swipeOut" in $$props) $$invalidate(15, swipeOut = $$new_props.swipeOut);
    if ("offsetBeforeRemove" in $$props) $$invalidate(16, offsetBeforeRemove = $$new_props.offsetBeforeRemove);
    if ("initialHeight" in $$props) $$invalidate(17, initialHeight = $$new_props.initialHeight);
    if ("toastRef" in $$props) $$invalidate(18, toastRef = $$new_props.toastRef);
    if ("offset" in $$props) $$invalidate(19, offset = $$new_props.offset);
    if ("closeTimerStartTimeRef" in $$props) closeTimerStartTimeRef = $$new_props.closeTimerStartTimeRef;
    if ("lastCloseTimerStartTimeRef" in $$props) lastCloseTimerStartTimeRef = $$new_props.lastCloseTimerStartTimeRef;
    if ("pointerStartRef" in $$props) pointerStartRef = $$new_props.pointerStartRef;
    if ("timeoutId" in $$props) $$invalidate(39, timeoutId = $$new_props.timeoutId);
    if ("remainingTime" in $$props) remainingTime = $$new_props.remainingTime;
    if ("effect" in $$props) $$subscribe_effect($$invalidate(20, effect = $$new_props.effect));
    if ("coords" in $$props) $$invalidate(21, coords = $$new_props.coords);
    if ("disabled" in $$props) $$invalidate(22, disabled = $$new_props.disabled);
    if ("isPromiseLoadingOrInfiniteDuration" in $$props) $$invalidate(40, isPromiseLoadingOrInfiniteDuration = $$new_props.isPromiseLoadingOrInfiniteDuration);
    if ("toastType" in $$props) $$invalidate(11, toastType = $$new_props.toastType);
    if ("toastDescription" in $$props) $$invalidate(41, toastDescription = $$new_props.toastDescription);
    if ("toastTitle" in $$props) $$invalidate(42, toastTitle = $$new_props.toastTitle);
    if ("toastsHeightBefore" in $$props) $$invalidate(43, toastsHeightBefore = $$new_props.toastsHeightBefore);
    if ("heightIndex" in $$props) $$invalidate(44, heightIndex = $$new_props.heightIndex);
    if ("toastDescriptionClass" in $$props) $$invalidate(23, toastDescriptionClass = $$new_props.toastDescriptionClass);
    if ("toastClass" in $$props) $$invalidate(24, toastClass = $$new_props.toastClass);
    if ("isVisible" in $$props) $$invalidate(25, isVisible = $$new_props.isVisible);
    if ("isFront" in $$props) $$invalidate(26, isFront = $$new_props.isFront);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*classes*/
    2) {
      $: $$invalidate(1, classes = { ...defaultClasses, ...classes });
    }
    if ($$self.$$.dirty[0] & /*index*/
    8) {
      $: $$invalidate(26, isFront = index === 0);
    }
    if ($$self.$$.dirty[0] & /*index*/
    8 | $$self.$$.dirty[1] & /*visibleToasts*/
    32) {
      $: $$invalidate(25, isVisible = index + 1 <= visibleToasts);
    }
    if ($$self.$$.dirty[0] & /*toast*/
    4) {
      $: $$invalidate(42, toastTitle = toast2.title);
    }
    if ($$self.$$.dirty[0] & /*toast*/
    4) {
      $: $$invalidate(41, toastDescription = toast2.description);
    }
    if ($$self.$$.dirty[0] & /*toast*/
    4) {
      $: $$invalidate(11, toastType = toast2.type);
    }
    if ($$self.$$.dirty[0] & /*toast*/
    4) {
      $: $$invalidate(24, toastClass = toast2.class || "");
    }
    if ($$self.$$.dirty[0] & /*toast*/
    4) {
      $: $$invalidate(23, toastDescriptionClass = toast2.descriptionClass || "");
    }
    if ($$self.$$.dirty[0] & /*toast*/
    4 | $$self.$$.dirty[1] & /*$heights*/
    32768) {
      $: $$invalidate(44, heightIndex = $heights.findIndex((height) => height.toastId === toast2.id) || 0);
    }
    if ($$self.$$.dirty[1] & /*position*/
    16) {
      $: $$invalidate(21, coords = position.split("-"));
    }
    if ($$self.$$.dirty[1] & /*$heights, heightIndex*/
    40960) {
      $: $$invalidate(43, toastsHeightBefore = $heights.reduce(
        (prev, curr, reducerIndex) => {
          if (reducerIndex >= heightIndex) return prev;
          return prev + curr.height;
        },
        0
      ));
    }
    if ($$self.$$.dirty[0] & /*toast, invert*/
    5) {
      $: $$invalidate(0, invert = toast2.invert || invert);
    }
    if ($$self.$$.dirty[0] & /*toastType*/
    2048) {
      $: $$invalidate(22, disabled = toastType === "loading");
    }
    if ($$self.$$.dirty[1] & /*heightIndex, toastsHeightBefore*/
    12288) {
      $: $$invalidate(19, offset = Math.round(heightIndex * GAP + toastsHeightBefore));
    }
    if ($$self.$$.dirty[1] & /*toastTitle, toastDescription*/
    3072) {
      $: toastTitle, toastDescription, updateHeights();
    }
    if ($$self.$$.dirty[0] & /*toast*/
    4 | $$self.$$.dirty[1] & /*timeoutId, duration*/
    384) {
      $: if (toast2.updated) {
        clearTimeout(timeoutId);
        remainingTime = toast2.duration || duration || TOAST_LIFETIME;
        startTimer();
      }
    }
    if ($$self.$$.dirty[0] & /*toast, toastType*/
    2052) {
      $: $$invalidate(40, isPromiseLoadingOrInfiniteDuration = toast2.promise && toastType === "loading" || toast2.duration === Number.POSITIVE_INFINITY);
    }
    if ($$self.$$.dirty[0] & /*expanded*/
    16 | $$self.$$.dirty[1] & /*isPromiseLoadingOrInfiniteDuration, interacting, timeoutId*/
    832) {
      $: $$subscribe_effect($$invalidate(20, effect = useEffect(() => {
        if (!isPromiseLoadingOrInfiniteDuration) {
          if (expanded || interacting) {
            pauseTimer();
          } else {
            startTimer();
          }
        }
        return () => clearTimeout(timeoutId);
      })));
    }
    if ($$self.$$.dirty[1] & /*$effect*/
    16384) {
      $: $effect;
    }
    if ($$self.$$.dirty[0] & /*toast*/
    4) {
      $: if (toast2.delete) {
        deleteToast();
      }
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    invert,
    classes,
    toast2,
    index,
    expanded,
    expandByDefault,
    closeButton,
    cancelButtonStyle,
    actionButtonStyle,
    descriptionClass,
    unstyled,
    toastType,
    mounted,
    removed,
    swiping,
    swipeOut,
    offsetBeforeRemove,
    initialHeight,
    toastRef,
    offset,
    effect,
    coords,
    disabled,
    toastDescriptionClass,
    toastClass,
    isVisible,
    isFront,
    $toasts,
    toasts,
    heights,
    deleteToast,
    onPointerDown,
    onPointerUp,
    onPointerMove,
    $$props,
    position,
    visibleToasts,
    interacting,
    duration,
    timeoutId,
    isPromiseLoadingOrInfiniteDuration,
    toastDescription,
    toastTitle,
    toastsHeightBefore,
    heightIndex,
    $effect,
    $heights,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2,
    li_binding
  ];
}
var Toast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      not_equal,
      {
        toast: 2,
        index: 3,
        expanded: 4,
        invert: 0,
        position: 35,
        visibleToasts: 36,
        expandByDefault: 5,
        closeButton: 6,
        interacting: 37,
        cancelButtonStyle: 7,
        actionButtonStyle: 8,
        duration: 38,
        descriptionClass: 9,
        classes: 1,
        unstyled: 10
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toast",
      options,
      id: create_fragment3.name
    });
  }
  get toast() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toast(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get index() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set index(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invert() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invert(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visibleToasts() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visibleToasts(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandByDefault() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandByDefault(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButton() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButton(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interacting() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interacting(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cancelButtonStyle() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cancelButtonStyle(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actionButtonStyle() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actionButtonStyle(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get descriptionClass() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set descriptionClass(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classes() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classes(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unstyled() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unstyled(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toast_default = Toast;

// node_modules/svelte-sonner/dist/Toaster.svelte
var { Boolean: Boolean_1 } = globals;
var file4 = "node_modules/svelte-sonner/dist/Toaster.svelte";
function add_css(target) {
  append_styles(target, "svelte-1fo5d1m", ":where(html[dir='ltr']),:where([data-sonner-toaster][dir='ltr']){--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}:where(html[dir='rtl']),:where([data-sonner-toaster][dir='rtl']){--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,\n			system-ui,\n			-apple-system,\n			BlinkMacSystemFont,\n			Segoe UI,\n			Roboto,\n			Helvetica Neue,\n			Arial,\n			Noto Sans,\n			sans-serif,\n			Apple Color Emoji,\n			Segoe UI Emoji,\n			Segoe UI Symbol,\n			Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999}:where([data-sonner-toaster][data-x-position='right']){right:max(var(--offset), env(safe-area-inset-right))}:where([data-sonner-toaster][data-x-position='left']){left:max(var(--offset), env(safe-area-inset-left))}:where([data-sonner-toaster][data-x-position='center']){left:50%;transform:translateX(-50%)}:where([data-sonner-toaster][data-y-position='top']){top:max(var(--offset), env(safe-area-inset-top))}:where([data-sonner-toaster][data-y-position='bottom']){bottom:max(var(--offset), env(safe-area-inset-bottom))}:where([data-sonner-toast]){--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform 400ms,\n			opacity 400ms,\n			height 400ms,\n			box-shadow 200ms;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled='true']){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0px 4px 12px rgba(0, 0, 0, 0.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0px 4px 12px rgba(0, 0, 0, 0.1),\n			0 0 0 2px rgba(0, 0, 0, 0.2)}:where([data-sonner-toast][data-y-position='top']){top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position='bottom']){bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise='true']) :where([data-icon])>svg{opacity:0;transform:scale(0.8);transform-origin:center;animation:sonner-fade-in 300ms ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled='true'] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity 400ms,\n			box-shadow 200ms}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px rgba(0, 0, 0, 0.4)}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0, 0, 0, 0.08)}:where([data-sonner-toast][data-theme='dark']) :where([data-cancel]){background:rgba(255, 255, 255, 0.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity 100ms,\n			background 200ms,\n			border-color 200ms}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0px 4px 12px rgba(0, 0, 0, 0.1),\n			0 0 0 2px rgba(0, 0, 0, 0.2)}:where([data-sonner-toast]) :where([data-disabled='true']){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping='true'])::before{content:'';position:absolute;left:0;right:0;height:100%;z-index:-1}:where(\n			[data-sonner-toast][data-y-position='top'][data-swiping='true']\n		)::before{bottom:50%;transform:scaleY(3) translateY(50%)}:where(\n			[data-sonner-toast][data-y-position='bottom'][data-swiping='true']\n		)::before{top:50%;transform:scaleY(3) translateY(-50%)}:where(\n			[data-sonner-toast][data-swiping='false'][data-removed='true']\n		)::before{content:'';position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast])::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted='true']){--y:translateY(0);opacity:1}:where([data-sonner-toast][data-expanded='false'][data-front='false']){--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before)))\n			scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity 400ms}:where(\n			[data-sonner-toast][data-expanded='false'][data-front='false'][data-styled='true']\n		)\n		>*{opacity:0}:where([data-sonner-toast][data-visible='false']){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted='true'][data-expanded='true']){--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where(\n			[data-sonner-toast][data-removed='true'][data-front='true'][data-swipe-out='false']\n		){--y:translateY(calc(var(--lift) * -100%));opacity:0}:where(\n			[data-sonner-toast][data-removed='true'][data-front='false'][data-swipe-out='false'][data-expanded='true']\n		){--y:translateY(\n			calc(var(--lift) * var(--offset) + var(--lift) * -100%)\n		);opacity:0}:where(\n			[data-sonner-toast][data-removed='true'][data-front='false'][data-swipe-out='false'][data-expanded='false']\n		){--y:translateY(40%);opacity:0;transition:transform 500ms,\n			opacity 200ms}:where(\n			[data-sonner-toast][data-removed='true'][data-front='false']\n		)::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping='true']{transform:var(--y) translateY(var(--swipe-amount, 0px));transition:none}[data-sonner-toast][data-swipe-out='true'][data-y-position='bottom'],[data-sonner-toast][data-swipe-out='true'][data-y-position='top']{animation:swipe-out 200ms ease-out forwards}@keyframes swipe-out{from{transform:translateY(\n				calc(var(--lift) * var(--offset) + var(--swipe-amount))\n			);opacity:1}to{transform:translateY(\n				calc(\n					var(--lift) * var(--offset) + var(--swipe-amount) +\n						var(--lift) * -100%\n				)\n			);opacity:0}}@media(max-width: 600px){[data-sonner-toaster]{position:fixed;--mobile-offset:16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset) * 2)}[data-sonner-toaster][data-x-position='left']{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position='bottom']{bottom:20px}[data-sonner-toaster][data-y-position='top']{top:20px}[data-sonner-toaster][data-x-position='center']{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme='light']{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 91%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 91%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 91%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme='light']\n		[data-sonner-toast][data-invert='true']{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-theme='dark']\n		[data-sonner-toast][data-invert='true']{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-theme='dark']{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 100%, 12%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 12%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-rich-colors='true'] [data-sonner-toast][data-type='success']{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-theme='dark']\n		[data-sonner-toast][data-type='default']\n		[data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-rich-colors='true']\n		[data-sonner-toast][data-type='success']\n		[data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors='true'] [data-sonner-toast][data-type='info']{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors='true']\n		[data-sonner-toast][data-type='info']\n		[data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors='true'] [data-sonner-toast][data-type='warning']{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors='true']\n		[data-sonner-toast][data-type='warning']\n		[data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors='true'] [data-sonner-toast][data-type='error']{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors='true']\n		[data-sonner-toast][data-type='error']\n		[data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible='false']{transform-origin:center;animation:sonner-fade-out 0.2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(0.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-0.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-0.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-0.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-0.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-0.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-0.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-0.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-0.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-0.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:0.15}}@media(prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none !important;animation:none !important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);transform-origin:center;transition:opacity 200ms,\n			transform 200ms}.sonner-loader[data-visible='false']{opacity:0;transform:scale(0.8) translate(-50%, -50%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9hc3Rlci5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL2hvbWUvaW5ub19XZWJVSS9mcm9udGVuZC9ub2RlX21vZHVsZXMvc3ZlbHRlLXNvbm5lci9kaXN0L1RvYXN0ZXIuc3ZlbHRlIl19 */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  child_ctx[40] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  child_ctx[40] = i;
  return child_ctx;
}
var get_loading_icon_slot_changes2 = (dirty) => ({});
var get_loading_icon_slot_context2 = (ctx) => ({ slot: "loading-icon" });
var get_success_icon_slot_changes2 = (dirty) => ({});
var get_success_icon_slot_context2 = (ctx) => ({ slot: "success-icon" });
var get_error_icon_slot_changes2 = (dirty) => ({});
var get_error_icon_slot_context2 = (ctx) => ({ slot: "error-icon" });
var get_warning_icon_slot_changes2 = (dirty) => ({});
var get_warning_icon_slot_context2 = (ctx) => ({ slot: "warning-icon" });
var get_info_icon_slot_changes2 = (dirty) => ({});
var get_info_icon_slot_context2 = (ctx) => ({ slot: "info-icon" });
function create_if_block3(ctx) {
  let section;
  let section_aria_label_value;
  let section_tabindex_value;
  let current;
  let each_value = ensure_array_like_dev(
    /*possiblePositions*/
    ctx[17]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      section = element("section");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { "aria-label": true, tabindex: true });
      var section_nodes = children(section);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(section_nodes);
      }
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(section, "aria-label", section_aria_label_value = `${/*containerAriaLabel*/
      ctx[1]} ${/*hotkeyLabel*/
      ctx[16]}`);
      attr_dev(section, "tabindex", section_tabindex_value = -1);
      add_location(section, file4, 161, 1, 5083);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(section, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$$props, actualTheme, richColors, dir, possiblePositions, $$restProps, listRef, $heights, offset, handleBlur, handleFocus, expanded, interacting, $toasts, invert, visibleToasts, closeButton, expand, toastOptions, duration*/
      31915005 | dirty[1] & /*$$scope*/
      16) {
        each_value = ensure_array_like_dev(
          /*possiblePositions*/
          ctx2[17]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(section, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*containerAriaLabel, hotkeyLabel*/
      65538 && section_aria_label_value !== (section_aria_label_value = `${/*containerAriaLabel*/
      ctx2[1]} ${/*hotkeyLabel*/
      ctx2[16]}`)) {
        attr_dev(section, "aria-label", section_aria_label_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(section);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(161:0) {#if $toasts.length > 0}",
    ctx
  });
  return block;
}
function fallback_block_4(ctx) {
  let loader;
  let current;
  loader = new Loader_default({
    props: {
      visible: (
        /*toast*/
        ctx[41].type === "loading"
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(loader.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(loader.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const loader_changes = {};
      if (dirty[0] & /*$toasts, possiblePositions*/
      133120) loader_changes.visible = /*toast*/
      ctx2[41].type === "loading";
      loader.$set(loader_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(loader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_4.name,
    type: "fallback",
    source: "(215:52)         ",
    ctx
  });
  return block;
}
function create_loading_icon_slot(ctx) {
  let current;
  const loading_icon_slot_template = (
    /*#slots*/
    ctx[27]["loading-icon"]
  );
  const loading_icon_slot = create_slot(
    loading_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    get_loading_icon_slot_context2
  );
  const loading_icon_slot_or_fallback = loading_icon_slot || fallback_block_4(ctx);
  const block = {
    c: function create() {
      if (loading_icon_slot_or_fallback) loading_icon_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (loading_icon_slot_or_fallback) loading_icon_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (loading_icon_slot_or_fallback) {
        loading_icon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (loading_icon_slot) {
        if (loading_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            loading_icon_slot,
            loading_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              loading_icon_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              get_loading_icon_slot_changes2
            ),
            get_loading_icon_slot_context2
          );
        }
      } else {
        if (loading_icon_slot_or_fallback && loading_icon_slot_or_fallback.p && (!current || dirty[0] & /*$toasts, possiblePositions*/
        133120)) {
          loading_icon_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(loading_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (loading_icon_slot_or_fallback) loading_icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_loading_icon_slot.name,
    type: "slot",
    source: "(215:6) ",
    ctx
  });
  return block;
}
function fallback_block_3(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { type: "success" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(218:52)         ",
    ctx
  });
  return block;
}
function create_success_icon_slot(ctx) {
  let current;
  const success_icon_slot_template = (
    /*#slots*/
    ctx[27]["success-icon"]
  );
  const success_icon_slot = create_slot(
    success_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    get_success_icon_slot_context2
  );
  const success_icon_slot_or_fallback = success_icon_slot || fallback_block_3(ctx);
  const block = {
    c: function create() {
      if (success_icon_slot_or_fallback) success_icon_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (success_icon_slot_or_fallback) success_icon_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (success_icon_slot_or_fallback) {
        success_icon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (success_icon_slot) {
        if (success_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            success_icon_slot,
            success_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              success_icon_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              get_success_icon_slot_changes2
            ),
            get_success_icon_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(success_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(success_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (success_icon_slot_or_fallback) success_icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_success_icon_slot.name,
    type: "slot",
    source: "(218:6) ",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let icon;
  let current;
  icon = new Icon_default({ props: { type: "error" }, $$inline: true });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(221:48)         ",
    ctx
  });
  return block;
}
function create_error_icon_slot(ctx) {
  let current;
  const error_icon_slot_template = (
    /*#slots*/
    ctx[27]["error-icon"]
  );
  const error_icon_slot = create_slot(
    error_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    get_error_icon_slot_context2
  );
  const error_icon_slot_or_fallback = error_icon_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      if (error_icon_slot_or_fallback) error_icon_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (error_icon_slot_or_fallback) error_icon_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (error_icon_slot_or_fallback) {
        error_icon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (error_icon_slot) {
        if (error_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            error_icon_slot,
            error_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              error_icon_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              get_error_icon_slot_changes2
            ),
            get_error_icon_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(error_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (error_icon_slot_or_fallback) error_icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_error_icon_slot.name,
    type: "slot",
    source: "(221:6) ",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { type: "warning" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(224:52)         ",
    ctx
  });
  return block;
}
function create_warning_icon_slot(ctx) {
  let current;
  const warning_icon_slot_template = (
    /*#slots*/
    ctx[27]["warning-icon"]
  );
  const warning_icon_slot = create_slot(
    warning_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    get_warning_icon_slot_context2
  );
  const warning_icon_slot_or_fallback = warning_icon_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      if (warning_icon_slot_or_fallback) warning_icon_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (warning_icon_slot_or_fallback) warning_icon_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (warning_icon_slot_or_fallback) {
        warning_icon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (warning_icon_slot) {
        if (warning_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            warning_icon_slot,
            warning_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              warning_icon_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              get_warning_icon_slot_changes2
            ),
            get_warning_icon_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(warning_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warning_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (warning_icon_slot_or_fallback) warning_icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_warning_icon_slot.name,
    type: "slot",
    source: "(224:6) ",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let icon;
  let current;
  icon = new Icon_default({ props: { type: "info" }, $$inline: true });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(227:46)         ",
    ctx
  });
  return block;
}
function create_info_icon_slot(ctx) {
  let current;
  const info_icon_slot_template = (
    /*#slots*/
    ctx[27]["info-icon"]
  );
  const info_icon_slot = create_slot(
    info_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    get_info_icon_slot_context2
  );
  const info_icon_slot_or_fallback = info_icon_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (info_icon_slot_or_fallback) info_icon_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (info_icon_slot_or_fallback) info_icon_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (info_icon_slot_or_fallback) {
        info_icon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (info_icon_slot) {
        if (info_icon_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            info_icon_slot,
            info_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              info_icon_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              get_info_icon_slot_changes2
            ),
            get_info_icon_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(info_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(info_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (info_icon_slot_or_fallback) info_icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_info_icon_slot.name,
    type: "slot",
    source: "(227:6) ",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  var _a, _b, _c, _d, _e;
  let first;
  let toast_1;
  let current;
  toast_1 = new Toast_default({
    props: {
      index: (
        /*index*/
        ctx[40]
      ),
      toast: (
        /*toast*/
        ctx[41]
      ),
      invert: (
        /*invert*/
        ctx[0]
      ),
      visibleToasts: (
        /*visibleToasts*/
        ctx[5]
      ),
      closeButton: (
        /*closeButton*/
        ctx[6]
      ),
      interacting: (
        /*interacting*/
        ctx[13]
      ),
      position: (
        /*position*/
        ctx[10]
      ),
      expandByDefault: (
        /*expand*/
        ctx[3]
      ),
      expanded: (
        /*expanded*/
        ctx[12]
      ),
      actionButtonStyle: (
        /*toastOptions*/
        ((_a = ctx[7]) == null ? void 0 : _a.actionButtonStyle) || ""
      ),
      cancelButtonStyle: (
        /*toastOptions*/
        ((_b = ctx[7]) == null ? void 0 : _b.cancelButtonStyle) || ""
      ),
      class: (
        /*toastOptions*/
        ((_c = ctx[7]) == null ? void 0 : _c.class) || ""
      ),
      descriptionClass: (
        /*toastOptions*/
        ((_d = ctx[7]) == null ? void 0 : _d.descriptionClass) || ""
      ),
      classes: (
        /*toastOptions*/
        ctx[7].classes || {}
      ),
      duration: (
        /*toastOptions*/
        ((_e = ctx[7]) == null ? void 0 : _e.duration) ?? /*duration*/
        ctx[4]
      ),
      unstyled: (
        /*toastOptions*/
        ctx[7].unstyled || false
      ),
      $$slots: {
        "info-icon": [create_info_icon_slot],
        "warning-icon": [create_warning_icon_slot],
        "error-icon": [create_error_icon_slot],
        "success-icon": [create_success_icon_slot],
        "loading-icon": [create_loading_icon_slot]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(toast_1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(toast_1.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(toast_1, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      var _a2, _b2, _c2, _d2, _e2;
      ctx = new_ctx;
      const toast_1_changes = {};
      if (dirty[0] & /*$toasts, possiblePositions*/
      133120) toast_1_changes.index = /*index*/
      ctx[40];
      if (dirty[0] & /*$toasts, possiblePositions*/
      133120) toast_1_changes.toast = /*toast*/
      ctx[41];
      if (dirty[0] & /*invert*/
      1) toast_1_changes.invert = /*invert*/
      ctx[0];
      if (dirty[0] & /*visibleToasts*/
      32) toast_1_changes.visibleToasts = /*visibleToasts*/
      ctx[5];
      if (dirty[0] & /*closeButton*/
      64) toast_1_changes.closeButton = /*closeButton*/
      ctx[6];
      if (dirty[0] & /*interacting*/
      8192) toast_1_changes.interacting = /*interacting*/
      ctx[13];
      if (dirty[0] & /*possiblePositions*/
      131072) toast_1_changes.position = /*position*/
      ctx[10];
      if (dirty[0] & /*expand*/
      8) toast_1_changes.expandByDefault = /*expand*/
      ctx[3];
      if (dirty[0] & /*expanded*/
      4096) toast_1_changes.expanded = /*expanded*/
      ctx[12];
      if (dirty[0] & /*toastOptions*/
      128) toast_1_changes.actionButtonStyle = /*toastOptions*/
      ((_a2 = ctx[7]) == null ? void 0 : _a2.actionButtonStyle) || "";
      if (dirty[0] & /*toastOptions*/
      128) toast_1_changes.cancelButtonStyle = /*toastOptions*/
      ((_b2 = ctx[7]) == null ? void 0 : _b2.cancelButtonStyle) || "";
      if (dirty[0] & /*toastOptions*/
      128) toast_1_changes.class = /*toastOptions*/
      ((_c2 = ctx[7]) == null ? void 0 : _c2.class) || "";
      if (dirty[0] & /*toastOptions*/
      128) toast_1_changes.descriptionClass = /*toastOptions*/
      ((_d2 = ctx[7]) == null ? void 0 : _d2.descriptionClass) || "";
      if (dirty[0] & /*toastOptions*/
      128) toast_1_changes.classes = /*toastOptions*/
      ctx[7].classes || {};
      if (dirty[0] & /*toastOptions, duration*/
      144) toast_1_changes.duration = /*toastOptions*/
      ((_e2 = ctx[7]) == null ? void 0 : _e2.duration) ?? /*duration*/
      ctx[4];
      if (dirty[0] & /*toastOptions*/
      128) toast_1_changes.unstyled = /*toastOptions*/
      ctx[7].unstyled || false;
      if (dirty[0] & /*$toasts, possiblePositions*/
      133120 | dirty[1] & /*$$scope*/
      16) {
        toast_1_changes.$$scope = { dirty, ctx };
      }
      toast_1.$set(toast_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(toast_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toast_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(toast_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(194:4) {#each $toasts.filter((toast) => (!toast.position && index === 0) || toast.position === position) as toast, index (toast.id)}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let ol;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let ol_tabindex_value;
  let ol_class_value;
  let ol_dir_value;
  let ol_data_y_position_value;
  let ol_data_x_position_value;
  let ol_style_value;
  let current;
  let mounted;
  let dispose;
  function func(...args) {
    return (
      /*func*/
      ctx[28](
        /*index*/
        ctx[40],
        /*position*/
        ctx[10],
        ...args
      )
    );
  }
  let each_value_1 = ensure_array_like_dev(
    /*$toasts*/
    ctx[11].filter(func)
  );
  const get_key = (ctx2) => (
    /*toast*/
    ctx2[41].id
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  let ol_levels = [
    { tabindex: ol_tabindex_value = -1 },
    {
      class: ol_class_value = /*$$props*/
      ctx[23].class
    },
    { "data-sonner-toaster": "" },
    { "data-theme": (
      /*actualTheme*/
      ctx[14]
    ) },
    {
      "data-rich-colors": (
        /*richColors*/
        ctx[2]
      )
    },
    {
      dir: ol_dir_value = /*dir*/
      ctx[9] === "auto" ? getDocumentDirection() : (
        /*dir*/
        ctx[9]
      )
    },
    {
      "data-y-position": ol_data_y_position_value = /*position*/
      ctx[10].split("-")[0]
    },
    {
      "data-x-position": ol_data_x_position_value = /*position*/
      ctx[10].split("-")[1]
    },
    {
      style: ol_style_value = /*$$props*/
      ctx[23].style
    },
    /*$$restProps*/
    ctx[24]
  ];
  let ol_data = {};
  for (let i = 0; i < ol_levels.length; i += 1) {
    ol_data = assign(ol_data, ol_levels[i]);
  }
  const block = {
    c: function create() {
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      ol = claim_element(nodes, "OL", {
        tabindex: true,
        class: true,
        "data-sonner-toaster": true,
        "data-theme": true,
        "data-rich-colors": true,
        dir: true,
        "data-y-position": true,
        "data-x-position": true,
        style: true
      });
      var ol_nodes = children(ol);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ol_nodes);
      }
      t = claim_space(ol_nodes);
      ol_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      set_attributes(ol, ol_data);
      set_style(ol, "--front-toast-height", `${/*$heights*/
      (_a = ctx[18][0]) == null ? void 0 : _a.height}px`);
      set_style(ol, "--offset", typeof /*offset*/
      ctx[8] === "number" ? `${/*offset*/
      ctx[8]}px` : (
        /*offset*/
        ctx[8] || VIEWPORT_OFFSET
      ));
      set_style(ol, "--width", `${TOAST_WIDTH}px`);
      set_style(ol, "--gap", `${GAP2}px`);
      add_location(ol, file4, 163, 3, 5209);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ol, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ol, null);
        }
      }
      append_hydration_dev(ol, t);
      ctx[29](ol);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            ol,
            "blur",
            /*handleBlur*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ol,
            "focus",
            /*handleFocus*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ol,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ol,
            "mousemove",
            /*mousemove_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ol,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ol,
            "pointerdown",
            /*pointerdown_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ol,
            "pointerup",
            /*pointerup_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (dirty[0] & /*$toasts, possiblePositions, invert, visibleToasts, closeButton, interacting, expand, expanded, toastOptions, duration*/
      145657 | dirty[1] & /*$$scope*/
      16) {
        each_value_1 = ensure_array_like_dev(
          /*$toasts*/
          ctx[11].filter(func)
        );
        group_outros();
        validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ol, outro_and_destroy_block, create_each_block_1, t, get_each_context_1);
        check_outros();
      }
      set_attributes(ol, ol_data = get_spread_update(ol_levels, [
        { tabindex: ol_tabindex_value },
        (!current || dirty[0] & /*$$props*/
        8388608 && ol_class_value !== (ol_class_value = /*$$props*/
        ctx[23].class)) && { class: ol_class_value },
        { "data-sonner-toaster": "" },
        (!current || dirty[0] & /*actualTheme*/
        16384) && { "data-theme": (
          /*actualTheme*/
          ctx[14]
        ) },
        (!current || dirty[0] & /*richColors*/
        4) && {
          "data-rich-colors": (
            /*richColors*/
            ctx[2]
          )
        },
        (!current || dirty[0] & /*dir*/
        512 && ol_dir_value !== (ol_dir_value = /*dir*/
        ctx[9] === "auto" ? getDocumentDirection() : (
          /*dir*/
          ctx[9]
        ))) && { dir: ol_dir_value },
        (!current || dirty[0] & /*possiblePositions*/
        131072 && ol_data_y_position_value !== (ol_data_y_position_value = /*position*/
        ctx[10].split("-")[0])) && {
          "data-y-position": ol_data_y_position_value
        },
        (!current || dirty[0] & /*possiblePositions*/
        131072 && ol_data_x_position_value !== (ol_data_x_position_value = /*position*/
        ctx[10].split("-")[1])) && {
          "data-x-position": ol_data_x_position_value
        },
        (!current || dirty[0] & /*$$props*/
        8388608 && ol_style_value !== (ol_style_value = /*$$props*/
        ctx[23].style)) && { style: ol_style_value },
        dirty[0] & /*$$restProps*/
        16777216 && /*$$restProps*/
        ctx[24]
      ]));
      set_style(ol, "--front-toast-height", `${/*$heights*/
      (_a = ctx[18][0]) == null ? void 0 : _a.height}px`);
      set_style(ol, "--offset", typeof /*offset*/
      ctx[8] === "number" ? `${/*offset*/
      ctx[8]}px` : (
        /*offset*/
        ctx[8] || VIEWPORT_OFFSET
      ));
      set_style(ol, "--width", `${TOAST_WIDTH}px`);
      set_style(ol, "--gap", `${GAP2}px`);
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ol);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(163:2) {#each possiblePositions as position, index}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$toasts*/
    ctx[11].length > 0 && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$toasts*/
        ctx2[11].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$toasts*/
          2048) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var VISIBLE_TOASTS_AMOUNT = 3;
var VIEWPORT_OFFSET = "32px";
var TOAST_WIDTH = 356;
var GAP2 = 14;
var DARK = "dark";
var LIGHT = "light";
function getInitialTheme(t) {
  if (t !== "system") {
    return t;
  }
  if (typeof window !== "undefined") {
    if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
      return DARK;
    }
    return LIGHT;
  }
  return LIGHT;
}
function getDocumentDirection() {
  if (typeof window === "undefined") return "ltr";
  if (typeof document === "undefined") return "ltr";
  const dirAttribute = document.documentElement.getAttribute("dir");
  if (dirAttribute === "auto" || !dirAttribute) {
    return window.getComputedStyle(document.documentElement).direction;
  }
  return dirAttribute;
}
function instance4($$self, $$props, $$invalidate) {
  let possiblePositions;
  let hotkeyLabel;
  const omit_props_names = [
    "invert",
    "theme",
    "position",
    "hotkey",
    "containerAriaLabel",
    "richColors",
    "expand",
    "duration",
    "visibleToasts",
    "closeButton",
    "toastOptions",
    "offset",
    "dir"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $toasts;
  let $heights;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toaster", slots, ["info-icon", "warning-icon", "error-icon", "success-icon", "loading-icon"]);
  let { invert = false } = $$props;
  let { theme = "light" } = $$props;
  let { position = "bottom-right" } = $$props;
  let { hotkey = ["altKey", "KeyT"] } = $$props;
  let { containerAriaLabel = "Notifications" } = $$props;
  let { richColors = false } = $$props;
  let { expand = false } = $$props;
  let { duration = 4e3 } = $$props;
  let { visibleToasts = VISIBLE_TOASTS_AMOUNT } = $$props;
  let { closeButton = false } = $$props;
  let { toastOptions = {} } = $$props;
  let { offset = null } = $$props;
  let { dir = getDocumentDirection() } = $$props;
  const { toasts, heights, reset } = toastState;
  validate_store(toasts, "toasts");
  component_subscribe($$self, toasts, (value) => $$invalidate(11, $toasts = value));
  validate_store(heights, "heights");
  component_subscribe($$self, heights, (value) => $$invalidate(18, $heights = value));
  let expanded = false;
  let interacting = false;
  let actualTheme = getInitialTheme(theme);
  let listRef;
  let lastFocusedElementRef = null;
  let isFocusWithinRef = false;
  onDestroy(() => {
    if (listRef && lastFocusedElementRef) {
      lastFocusedElementRef.focus({ preventScroll: true });
      lastFocusedElementRef = null;
      isFocusWithinRef = false;
    }
  });
  onMount(() => {
    reset();
    const handleKeydown = (event) => {
      const isHotkeyPressed = hotkey.every((key) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        event[key] || event.code === key
      ));
      if (isHotkeyPressed) {
        $$invalidate(12, expanded = true);
        listRef == null ? void 0 : listRef.focus();
      }
      if (event.code === "Escape" && (document.activeElement === listRef || (listRef == null ? void 0 : listRef.contains(document.activeElement)))) {
        $$invalidate(12, expanded = false);
      }
    };
    document.addEventListener("keydown", handleKeydown);
    return () => {
      document.removeEventListener("keydown", handleKeydown);
    };
  });
  function handleBlur(event) {
    if (isFocusWithinRef && !event.currentTarget.contains(event.relatedTarget)) {
      isFocusWithinRef = false;
      if (lastFocusedElementRef) {
        lastFocusedElementRef.focus({ preventScroll: true });
        lastFocusedElementRef = null;
      }
    }
  }
  function handleFocus(event) {
    if (!isFocusWithinRef) {
      isFocusWithinRef = true;
      lastFocusedElementRef = event.relatedTarget;
    }
  }
  const func = (index, position2, toast2) => !toast2.position && index === 0 || toast2.position === position2;
  function ol_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      listRef = $$value;
      $$invalidate(15, listRef);
    });
  }
  const mouseenter_handler = () => $$invalidate(12, expanded = true);
  const mousemove_handler = () => $$invalidate(12, expanded = true);
  const mouseleave_handler = () => {
    if (!interacting) {
      $$invalidate(12, expanded = false);
    }
  };
  const pointerdown_handler = () => $$invalidate(13, interacting = true);
  const pointerup_handler = () => $$invalidate(13, interacting = false);
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("invert" in $$new_props) $$invalidate(0, invert = $$new_props.invert);
    if ("theme" in $$new_props) $$invalidate(25, theme = $$new_props.theme);
    if ("position" in $$new_props) $$invalidate(10, position = $$new_props.position);
    if ("hotkey" in $$new_props) $$invalidate(26, hotkey = $$new_props.hotkey);
    if ("containerAriaLabel" in $$new_props) $$invalidate(1, containerAriaLabel = $$new_props.containerAriaLabel);
    if ("richColors" in $$new_props) $$invalidate(2, richColors = $$new_props.richColors);
    if ("expand" in $$new_props) $$invalidate(3, expand = $$new_props.expand);
    if ("duration" in $$new_props) $$invalidate(4, duration = $$new_props.duration);
    if ("visibleToasts" in $$new_props) $$invalidate(5, visibleToasts = $$new_props.visibleToasts);
    if ("closeButton" in $$new_props) $$invalidate(6, closeButton = $$new_props.closeButton);
    if ("toastOptions" in $$new_props) $$invalidate(7, toastOptions = $$new_props.toastOptions);
    if ("offset" in $$new_props) $$invalidate(8, offset = $$new_props.offset);
    if ("dir" in $$new_props) $$invalidate(9, dir = $$new_props.dir);
    if ("$$scope" in $$new_props) $$invalidate(35, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    toastState,
    Toast: Toast_default,
    Loader: Loader_default,
    Icon: Icon_default,
    VISIBLE_TOASTS_AMOUNT,
    VIEWPORT_OFFSET,
    TOAST_WIDTH,
    GAP: GAP2,
    DARK,
    LIGHT,
    getInitialTheme,
    getDocumentDirection,
    invert,
    theme,
    position,
    hotkey,
    containerAriaLabel,
    richColors,
    expand,
    duration,
    visibleToasts,
    closeButton,
    toastOptions,
    offset,
    dir,
    toasts,
    heights,
    reset,
    expanded,
    interacting,
    actualTheme,
    listRef,
    lastFocusedElementRef,
    isFocusWithinRef,
    handleBlur,
    handleFocus,
    hotkeyLabel,
    possiblePositions,
    $toasts,
    $heights
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("invert" in $$props) $$invalidate(0, invert = $$new_props.invert);
    if ("theme" in $$props) $$invalidate(25, theme = $$new_props.theme);
    if ("position" in $$props) $$invalidate(10, position = $$new_props.position);
    if ("hotkey" in $$props) $$invalidate(26, hotkey = $$new_props.hotkey);
    if ("containerAriaLabel" in $$props) $$invalidate(1, containerAriaLabel = $$new_props.containerAriaLabel);
    if ("richColors" in $$props) $$invalidate(2, richColors = $$new_props.richColors);
    if ("expand" in $$props) $$invalidate(3, expand = $$new_props.expand);
    if ("duration" in $$props) $$invalidate(4, duration = $$new_props.duration);
    if ("visibleToasts" in $$props) $$invalidate(5, visibleToasts = $$new_props.visibleToasts);
    if ("closeButton" in $$props) $$invalidate(6, closeButton = $$new_props.closeButton);
    if ("toastOptions" in $$props) $$invalidate(7, toastOptions = $$new_props.toastOptions);
    if ("offset" in $$props) $$invalidate(8, offset = $$new_props.offset);
    if ("dir" in $$props) $$invalidate(9, dir = $$new_props.dir);
    if ("expanded" in $$props) $$invalidate(12, expanded = $$new_props.expanded);
    if ("interacting" in $$props) $$invalidate(13, interacting = $$new_props.interacting);
    if ("actualTheme" in $$props) $$invalidate(14, actualTheme = $$new_props.actualTheme);
    if ("listRef" in $$props) $$invalidate(15, listRef = $$new_props.listRef);
    if ("lastFocusedElementRef" in $$props) lastFocusedElementRef = $$new_props.lastFocusedElementRef;
    if ("isFocusWithinRef" in $$props) isFocusWithinRef = $$new_props.isFocusWithinRef;
    if ("hotkeyLabel" in $$props) $$invalidate(16, hotkeyLabel = $$new_props.hotkeyLabel);
    if ("possiblePositions" in $$props) $$invalidate(17, possiblePositions = $$new_props.possiblePositions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*position, $toasts*/
    3072) {
      $: $$invalidate(17, possiblePositions = Array.from(new Set([
        position,
        ...$toasts.filter((toast2) => toast2.position).map((toast2) => toast2.position)
      ].filter(Boolean))));
    }
    if ($$self.$$.dirty[0] & /*hotkey*/
    67108864) {
      $: $$invalidate(16, hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, ""));
    }
    if ($$self.$$.dirty[0] & /*$toasts*/
    2048) {
      $: if ($toasts.length <= 1) {
        $$invalidate(12, expanded = false);
      }
    }
    if ($$self.$$.dirty[0] & /*$toasts*/
    2048) {
      $: {
        const toastsToDismiss = $toasts.filter((toast2) => toast2.dismiss && !toast2.delete);
        if (toastsToDismiss.length > 0) {
          const updatedToasts = $toasts.map((toast2) => {
            const matchingToast = toastsToDismiss.find((dismissToast) => dismissToast.id === toast2.id);
            if (matchingToast) {
              return { ...toast2, delete: true };
            }
            return toast2;
          });
          toasts.set(updatedToasts);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*theme*/
    33554432) {
      $: {
        if (theme !== "system") {
          $$invalidate(14, actualTheme = theme);
        }
        if (typeof window !== "undefined") {
          if (theme === "system") {
            if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
              $$invalidate(14, actualTheme = DARK);
            } else {
              $$invalidate(14, actualTheme = LIGHT);
            }
          }
          const mediaQueryList = window.matchMedia("(prefers-color-scheme: dark)");
          const changeHandler = ({ matches }) => {
            $$invalidate(14, actualTheme = matches ? DARK : LIGHT);
          };
          if ("addEventListener" in mediaQueryList) {
            mediaQueryList.addEventListener("change", changeHandler);
          } else {
            mediaQueryList.addListener(changeHandler);
          }
        }
      }
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    invert,
    containerAriaLabel,
    richColors,
    expand,
    duration,
    visibleToasts,
    closeButton,
    toastOptions,
    offset,
    dir,
    position,
    $toasts,
    expanded,
    interacting,
    actualTheme,
    listRef,
    hotkeyLabel,
    possiblePositions,
    $heights,
    toasts,
    heights,
    handleBlur,
    handleFocus,
    $$props,
    $$restProps,
    theme,
    hotkey,
    slots,
    func,
    ol_binding,
    mouseenter_handler,
    mousemove_handler,
    mouseleave_handler,
    pointerdown_handler,
    pointerup_handler,
    $$scope
  ];
}
var Toaster = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        invert: 0,
        theme: 25,
        position: 10,
        hotkey: 26,
        containerAriaLabel: 1,
        richColors: 2,
        expand: 3,
        duration: 4,
        visibleToasts: 5,
        closeButton: 6,
        toastOptions: 7,
        offset: 8,
        dir: 9
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toaster",
      options,
      id: create_fragment4.name
    });
  }
  get invert() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invert(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hotkey() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hotkey(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerAriaLabel() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerAriaLabel(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get richColors() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set richColors(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expand() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expand(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visibleToasts() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visibleToasts(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButton() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButton(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toastOptions() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toastOptions(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dir() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dir(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toaster_default = Toaster;
export {
  Icon_default as Icon,
  Loader_default as Loader,
  Toaster_default as Toaster,
  toast
};
//# sourceMappingURL=svelte-sonner.js.map
